import argparse
import os
import csv
import numpy as np
import tensorflow.keras.models as tfm
import imageio
import matplotlib.pyplot as plt

features = 1

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='uts_video.py generates an animated git that shows the forecast curve computed on an input time series as the epochs change.')

    parser.add_argument('--modelsnap',
                        type=str,
                        dest='model_snapshots_path',
                        required=True,
                        help='model snapshots directory (generated by uts_fit.py with option --modelsnapout)')

    parser.add_argument('--ts',
                        type=str,
                        dest='timeseries_filename',
                        required=True,
                        help='time series file (csv format)')

    parser.add_argument('--samplelength',
                        type=int,
                        dest='sample_length',
                        required=False,
                        default=5,
                        help='sample length')

    parser.add_argument('--forecastlength',
                        type=int,
                        dest='forecast_length',
                        required=False,
                        default=10,
                        help='length of forecast (number of values to predict)')

    parser.add_argument('--savevideo',
                        type=str,
                        dest='save_gif_video',
                        required=True,
                        default='',
                        help='the animated .gif file name to generate')

    parser.add_argument('--fps',
                        type=int,
                        dest='fps',
                        required=False,
                        default=10,
                        help='frame per seconds')

    parser.add_argument('--width',
                        type=float,
                        dest='width',
                        required=False,
                        default=9.0,
                        help='width of animated git (in inch)')

    parser.add_argument('--height',
                        type=float,
                        dest='height',
                        required=False,
                        default=6.0,
                        help='height of animated git (in inch)')

    args = parser.parse_args()

    print("#### Started {} {} ####".format(__file__, args));

    y_timeseries = []
    with open(args.timeseries_filename) as csv_file:
        csv_reader = csv.reader(csv_file, delimiter=',')
        next(csv_reader, None)
        for row in csv_reader:
            y_timeseries.append(float(row[0]))

    miny = min(y_timeseries) #TODO: not good in general
    maxy = max(y_timeseries) #TODO: not good in general

    miny = miny - 0.1 * (maxy - miny)
    maxy = maxy + 0.1 * (maxy - miny)

    frames = []
    fig, ax = plt.subplots(figsize=(args.width, args.height))

    epochs = [mdl for mdl in sorted(os.listdir(args.model_snapshots_path))]
    for epoch in epochs:
        model = tfm.load_model(os.path.join(args.model_snapshots_path, epoch))

        y_forecast = np.array([])
        to_predict_flat = np.array(y_timeseries[-args.sample_length:])
        for i in range(args.forecast_length):
            to_predict = to_predict_flat.reshape((1, args.sample_length, features))
            ###to_predict = to_predict_flat.reshape((1, 1, args.sample_length, features))
            prediction = model.predict(to_predict, verbose=0)
            print('Forecast of #{}: {}'.format(i+1, prediction))
            y_forecast = np.append(y_forecast, prediction)
            to_predict_flat = np.delete(to_predict_flat, 0)
            to_predict_flat = np.append(to_predict_flat, prediction)

        plt.cla()
        ax.set_xlim(0, len(y_timeseries) + args.forecast_length)
        ax.set_ylim(miny, maxy)
        ax.set_title('Epoch = %d' % int(epoch), fontdict={'size': 10, 'color': 'orange'})
        plt.scatter(range(len(y_timeseries)), y_timeseries, color='blue', s=1, marker='.')
        plt.scatter(range(len(y_timeseries), len(y_timeseries) + args.forecast_length), y_forecast, color='red', s=1, marker='.')

        # Used to return the plot as an image array
        # (https://ndres.me/post/matplotlib-animated-gifs-easily/)
        fig.canvas.draw()
        frame = np.frombuffer(fig.canvas.tostring_rgb(), dtype='uint8')
        frame  = frame.reshape(fig.canvas.get_width_height()[::-1] + (3,))
        frames.append(frame)
        print ('Generated frame for epoch {}'.format(epoch))

    imageio.mimsave(args.save_gif_video, frames, fps=args.fps)
    print ('Saved {} animated gif'.format(args.save_gif_video))

    print("#### Terminated {} ####".format(__file__));
